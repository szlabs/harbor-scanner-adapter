/*
 * Harbor Scanner Adapter API
 *
 * ## Overview  This API must be implemented in order to register a new artifact scanner in [Harbor](https://goharbor.io) registry.  The [/scan](#operation/AcceptScanRequest) and [/scan/{scan_request_id}/report](#operation/GetScanReport) operations are responsible for the actual scanning and return a scan report that is visible in the Harbor web console.  The [/scan](#operation/AcceptScanRequest) operation is asynchronous. It should enqueue the job for processing a scan request and return the identifier. This allows Harbor to poll a corresponding scan report with the [/scan/{scan_request_id}/report](#operation/GetScanReport) operation. Harbor will call the [/scan/{scan_request_id}/report](#operation/GetScanReport) operation periodically periodically until it returns 200 or 500 status codes.  The [/metadata](#operation/GetMetadata) operation allows a Harbor admin to configure and register a scanner and discover its capabilities.  ## Supported consumed MIME spec  - `application/vnd.oci.image.manifest.v1+json` - `application/vnd.docker.distribution.manifest.v2+json`  ## Supported produced MIME spec  - `application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0` - `application/vnd.security.vulnerability.report; version=1.1` - `application/vnd.scanner.adapter.vuln.report.raw` - `application/vnd.security.cis.report; version=1.0`
 *
 * API version: 1.2
 * Contact: cncf-harbor-maintainers@lists.cncf.io
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package main

import (
	"context"
	"crypto/tls"
	"flag"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"time"

	"github.com/spf13/viper"

	"github.com/szlabs/harbor-scanner-adapter/pkg/config"
	"github.com/szlabs/harbor-scanner-adapter/pkg/zlog"
	"github.com/szlabs/harbor-scanner-adapter/server/mux"
)

func main() {
	// Get the logger first.
	zl := zlog.Logger()

	var wait time.Duration
	var configFile string
	flag.DurationVar(&wait, "graceful-timeout", time.Second*15, "the duration for which the server gracefully wait for existing connections to finish - e.g. 15s or 1m")
	flag.StringVar(&configFile, "config", "", "configuration yaml file for the scanner adapter API server")
	flag.Parse()

	// Load config first.
	if err := config.Load(configFile); err != nil {
		zl.Fatal("error", err)
	}

	// Create HTTP server and routes.
	r := mux.NewRouter()
	srv := &http.Server{
		Addr:         listenAddr(),
		WriteTimeout: time.Second * 15,
		ReadTimeout:  time.Second * 15,
		IdleTimeout:  time.Second * 60,
		Handler:      r,
	}

	// Configure HTTPS server.
	if isHTTPS() {
		if err := configHTTPS(srv); err != nil {
			zl.Fatal("error", err)
		}
	}

	// Run our server in a goroutine so that it doesn't block.
	go func() {
		var err error

		if isHTTPS() {
			err = srv.ListenAndServeTLS("", "")
		} else {
			err = srv.ListenAndServe()
		}

		if err != nil {
			zl.Error(err)
		}
	}()

	zl.Infow("Harbor scanner adapter API Server started", "address",
		fmt.Sprintf("%s://%s",
			strings.ToLower(
				viper.GetString("server.protocol")), listenAddr()))

	c := make(chan os.Signal, 1)
	// We'll accept graceful shutdowns when quit via SIGINT (Ctrl+C)
	// SIGKILL, SIGQUIT or SIGTERM (Ctrl+/) will not be caught.
	signal.Notify(c, os.Interrupt)

	// Block until we receive our signal.
	<-c

	// Create a deadline to wait for.
	ctx, cancel := context.WithTimeout(context.Background(), wait)
	defer cancel()
	// Doesn't block if no connections, but will otherwise wait
	// until the timeout deadline.
	if err := srv.Shutdown(ctx); err != nil {
		zl.Fatal("error", err)
	}
	// Optionally, you could run srv.Shutdown in a goroutine and block on
	// <-ctx.Done() if your application should wait for other services
	// to finalize based on context cancellation.
	zl.Info("API server is shutting down")
	os.Exit(0)
}

func isHTTPS() bool {
	return strings.ToUpper(viper.GetString("server.protocol")) == "HTTPS"
}

func listenAddr() string {
	return fmt.Sprintf(
		"%s:%s",
		viper.GetString("server.host"),
		viper.GetString("server.port"),
	)
}

func configHTTPS(srv *http.Server) error {
	if srv == nil {
		return nil
	}

	configHTTPSError := func(section string, err error) error {
		return fmt.Errorf("configure HTTPS server error: %s: %w\n", section, err)
	}

	cert := viper.GetString("server.cert")
	key := viper.GetString("server.key")

	if err := fileExists(cert); err != nil {
		return configHTTPSError("check cert file error", err)
	}

	if err := fileExists(key); err != nil {
		return configHTTPSError("check key file error", err)
	}

	certificate, err := tls.LoadX509KeyPair(cert, key)
	if err != nil {
		return configHTTPSError("load X509 key pair error", err)
	}

	srv.TLSConfig = &tls.Config{
		Certificates: []tls.Certificate{certificate},
	}

	return nil
}

func fileExists(path string) error {
	_, err := os.Stat(path)
	return err
}
